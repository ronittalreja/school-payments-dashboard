// fixDatabase.js - Complete database fix script
const mongoose = require('mongoose');
require('dotenv').config();

// Connect to MongoDB
async function connectDB() {
  try {
    const mongoUri = process.env.MONGODB_URI || process.env.MONGO_URI || 'mongodb://localhost:27017/school';
    await mongoose.connect(mongoUri, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('✅ MongoDB connected successfully');
    console.log('📍 Connected to:', mongoUri.replace(/\/\/.*:.*@/, '//***:***@')); // Hide credentials in log
  } catch (error) {
    console.error('❌ MongoDB connection error:', error);
    process.exit(1);
  }
}

// Import your existing models (make sure paths are correct)
let Order, OrderStatus, WebhookLog;

try {
  Order = require('./models/Order');
  OrderStatus = require('./models/OrderStatus');
  // WebhookLog = require('./models/WebhookLog'); // Uncomment if you have this model
} catch (error) {
  console.error('❌ Error importing models. Make sure you run this script from your backend root directory.');
  console.error('Current directory:', process.cwd());
  process.exit(1);
}

// Step 1: Clean up and fix existing data
async function cleanupExistingData() {
  console.log('\n🧹 Step 1: Cleaning up existing data...');
  
  try {
    // Find OrderStatus records with null or duplicate collect_id
    const problematicOrderStatuses = await OrderStatus.find({
      $or: [
        { collect_id: null },
        { collect_id: '' },
        { collect_id: { $exists: false } }
      ]
    });

    console.log(`📊 Found ${problematicOrderStatuses.length} OrderStatus records with null/missing collect_id`);

    // Delete problematic OrderStatus records (they'll be recreated properly)
    if (problematicOrderStatuses.length > 0) {
      const deleteResult = await OrderStatus.deleteMany({
        $or: [
          { collect_id: null },
          { collect_id: '' },
          { collect_id: { $exists: false } }
        ]
      });
      console.log(`🗑️  Deleted ${deleteResult.deletedCount} problematic OrderStatus records`);
    }

    // Find Orders with missing collect_request_id
    const ordersWithoutCollectRequestId = await Order.find({
      $or: [
        { collect_request_id: null },
        { collect_request_id: '' },
        { collect_request_id: { $exists: false } }
      ]
    });

    console.log(`📊 Found ${ordersWithoutCollectRequestId.length} Orders with missing collect_request_id`);

    // Update Orders with missing collect_request_id
    for (const order of ordersWithoutCollectRequestId) {
      const autoGeneratedId = `auto_${order.custom_order_id}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
      await Order.updateOne(
        { _id: order._id },
        { collect_request_id: autoGeneratedId }
      );
      console.log(`🔧 Updated Order ${order.custom_order_id} with collect_request_id: ${autoGeneratedId}`);
    }

  } catch (error) {
    console.error('❌ Error during data cleanup:', error);
    throw error;
  }
}

// Step 2: Drop and recreate indexes
async function fixIndexes() {
  console.log('\n🔧 Step 2: Fixing database indexes...');
  
  try {
    // Fix OrderStatus collection indexes
    console.log('📋 Fixing OrderStatus indexes...');
    
    // Drop all existing indexes except _id
    try {
      const orderStatusIndexes = await OrderStatus.collection.listIndexes().toArray();
      for (const index of orderStatusIndexes) {
        if (index.name !== '_id_') {
          try {
            await OrderStatus.collection.dropIndex(index.name);
            console.log(`✅ Dropped OrderStatus index: ${index.name}`);
          } catch (e) {
            console.log(`ℹ️  Could not drop ${index.name}: ${e.message}`);
          }
        }
      }
    } catch (e) {
      console.log('ℹ️  No existing OrderStatus indexes to drop');
    }

    // Create new OrderStatus indexes
    await OrderStatus.collection.createIndex({ "collect_id": 1 }, { unique: true, name: "collect_id_unique" });
    await OrderStatus.collection.createIndex({ "collect_request_id": 1 }, { sparse: true, name: "collect_request_id_sparse" });
    await OrderStatus.collection.createIndex({ "status": 1 }, { name: "status_index" });
    console.log('✅ Created OrderStatus indexes');

    // Fix Orders collection indexes
    console.log('📋 Fixing Orders indexes...');
    
    // Drop all existing indexes except _id
    try {
      const orderIndexes = await Order.collection.listIndexes().toArray();
      for (const index of orderIndexes) {
        if (index.name !== '_id_') {
          try {
            await Order.collection.dropIndex(index.name);
            console.log(`✅ Dropped Order index: ${index.name}`);
          } catch (e) {
            console.log(`ℹ️  Could not drop ${index.name}: ${e.message}`);
          }
        }
      }
    } catch (e) {
      console.log('ℹ️  No existing Order indexes to drop');
    }

    // Create new Order indexes
    await Order.collection.createIndex({ "school_id": 1 }, { name: "school_id_index" });
    await Order.collection.createIndex({ "custom_order_id": 1 }, { unique: true, name: "custom_order_id_unique" });
    await Order.collection.createIndex({ "collect_request_id": 1 }, { sparse: true, unique: true, name: "collect_request_id_unique" });
    await Order.collection.createIndex({ "status": 1 }, { name: "order_status_index" });
    console.log('✅ Created Order indexes');

  } catch (error) {
    console.error('❌ Error fixing indexes:', error);
    throw error;
  }
}

// Step 3: Recreate missing OrderStatus records
async function recreateOrderStatusRecords() {
  console.log('\n🔄 Step 3: Recreating missing OrderStatus records...');
  
  try {
    // Get all orders
    const allOrders = await Order.find({});
    console.log(`📊 Found ${allOrders.length} orders to process`);

    let createdCount = 0;
    
    for (const order of allOrders) {
      // Check if OrderStatus exists for this order
      const existingOrderStatus = await OrderStatus.findOne({ collect_id: order.custom_order_id });
      
      if (!existingOrderStatus) {
        // Create new OrderStatus
        const newOrderStatus = new OrderStatus({
          collect_id: order.custom_order_id,
          collect_request_id: order.collect_request_id,
          order_amount: order.amount,
          transaction_amount: 0,
          payment_mode: '',
          payment_details: null,
          bank_reference: '',
          payment_message: '',
          status: order.status === 'success' ? 'SUCCESS' : 
                 order.status === 'failed' ? 'FAILED' : 
                 order.status === 'processing' ? 'processing' : 'pending',
          error_message: '',
          payment_time: order.createdAt,
          gateway: order.gateway_name || 'Edviron'
        });

        await newOrderStatus.save();
        createdCount++;
        console.log(`✅ Created OrderStatus for order: ${order.custom_order_id}`);
      }
    }

    console.log(`🎉 Created ${createdCount} missing OrderStatus records`);

  } catch (error) {
    console.error('❌ Error recreating OrderStatus records:', error);
    throw error;
  }
}

// Step 4: Verify the fix
async function verifyFix() {
  console.log('\n✅ Step 4: Verifying the fix...');
  
  try {
    // Check Orders
    const totalOrders = await Order.countDocuments();
    const ordersWithCollectRequestId = await Order.countDocuments({ collect_request_id: { $exists: true, $ne: null, $ne: '' } });
    
    console.log(`📊 Orders: ${totalOrders} total, ${ordersWithCollectRequestId} with collect_request_id`);

    // Check OrderStatus
    const totalOrderStatuses = await OrderStatus.countDocuments();
    const orderStatusesWithCollectId = await OrderStatus.countDocuments({ collect_id: { $exists: true, $ne: null, $ne: '' } });
    
    console.log(`📊 OrderStatuses: ${totalOrderStatuses} total, ${orderStatusesWithCollectId} with collect_id`);

    // Check for any remaining issues
    const problematicOrders = await Order.find({
      $or: [
        { custom_order_id: null },
        { custom_order_id: '' },
        { collect_request_id: null },
        { collect_request_id: '' }
      ]
    });

    const problematicOrderStatuses = await OrderStatus.find({
      $or: [
        { collect_id: null },
        { collect_id: '' }
      ]
    });

    if (problematicOrders.length === 0 && problematicOrderStatuses.length === 0) {
      console.log('🎉 SUCCESS! No remaining data issues found.');
    } else {
      console.log(`⚠️  WARNING: Found ${problematicOrders.length} problematic orders and ${problematicOrderStatuses.length} problematic order statuses`);
    }

    // List all indexes
    console.log('\n📋 Current OrderStatus indexes:');
    const orderStatusIndexes = await OrderStatus.collection.listIndexes().toArray();
    orderStatusIndexes.forEach(index => {
      console.log(`  - ${index.name}: ${JSON.stringify(index.key)}`);
    });

    console.log('\n📋 Current Orders indexes:');
    const orderIndexes = await Order.collection.listIndexes().toArray();
    orderIndexes.forEach(index => {
      console.log(`  - ${index.name}: ${JSON.stringify(index.key)}`);
    });

  } catch (error) {
    console.error('❌ Error during verification:', error);
    throw error;
  }
}

// Main execution function
async function main() {
  try {
    console.log('🚀 Starting complete database fix process...');
    console.log('📁 Current working directory:', process.cwd());
    
    await connectDB();
    
    await cleanupExistingData();
    await fixIndexes();
    await recreateOrderStatusRecords();
    await verifyFix();
    
    console.log('\n🎉 SUCCESS! Database fix process completed successfully.');
    console.log('\n✅ Your database is now clean and ready to use.');
    console.log('💡 You can now restart your application and test webhook functionality.');
    
  } catch (error) {
    console.error('\n❌ Database fix process failed:', error);
    process.exit(1);
  } finally {
    await mongoose.connection.close();
    console.log('📪 Database connection closed.');
    process.exit(0);
  }
}

// Run the script
if (require.main === module) {
  main();
}

module.exports = {
  cleanupExistingData,
  fixIndexes,
  recreateOrderStatusRecords,
  verifyFix
};